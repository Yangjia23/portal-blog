import{o as n,c as s,d as a}from"./app.793f0f95.js";const o='{"title":"一、“伪模块化”","description":"","frontmatter":{},"headers":[{"level":2,"title":"一、“伪模块化”","slug":"一、“伪模块化”"},{"level":3,"title":"1.1、全局 function 格式","slug":"_1-1、全局-function-格式"},{"level":3,"title":"1.2、namesapce 格式","slug":"_1-2、namesapce-格式"},{"level":3,"title":"1.3、IIEF 格式","slug":"_1-3、iief-格式"},{"level":2,"title":"二、CommonJS 规范","slug":"二、commonjs-规范"},{"level":2,"title":"三、AMD 规范","slug":"三、amd-规范"},{"level":2,"title":"四、CMD 规范","slug":"四、cmd-规范"},{"level":2,"title":"五、UMD 规范","slug":"五、umd-规范"},{"level":2,"title":"六、ES 模块化规范","slug":"六、es-模块化规范"},{"level":2,"title":"七、区别","slug":"七、区别"}],"relativePath":"frontend-graph/工程化/1、模块化机制.md","lastUpdated":1625365301299}',p={},t=a('<p>前端模块化规范</p><h2 id="一、“伪模块化”"><a class="header-anchor" href="#一、“伪模块化”" aria-hidden="true">#</a> 一、“伪模块化”</h2><h3 id="_1-1、全局-function-格式"><a class="header-anchor" href="#_1-1、全局-function-格式" aria-hidden="true">#</a> 1.1、全局 <code>function</code> 格式</h3><p><strong>说明：</strong> 将不同的功能封装到不同的全局函数中</p><p><strong>代码实现:</strong></p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">m1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> \n  <span class="token comment">//...</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">function</span> <span class="token function">m2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n   <span class="token comment">//...</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p><strong>缺点:</strong></p><ul><li>全局命名空间污染，容易造成命名冲突、数据不安全</li><li>模块之间看不出依赖关系</li></ul><h3 id="_1-2、namesapce-格式"><a class="header-anchor" href="#_1-2、namesapce-格式" aria-hidden="true">#</a> 1.2、<code>namesapce</code> 格式</h3><p><strong>说明：</strong> 相比于全局 <code>function</code>，减少了全局变量，解决命名冲突</p><p><strong>代码实现:</strong></p><div class="language-js"><pre><code><span class="token keyword">let</span> myModule <span class="token operator">=</span> <span class="token punctuation">{</span>  \n  name<span class="token operator">:</span> <span class="token string">&#39;Hello&#39;</span><span class="token punctuation">,</span>\n  <span class="token function-variable function">getName</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p><strong>缺点:</strong></p><ul><li>数据不安全，外面可之间修改模块内部的数据</li></ul><h3 id="_1-3、iief-格式"><a class="header-anchor" href="#_1-3、iief-格式" aria-hidden="true">#</a> 1.3、<code>IIEF</code> 格式</h3><p><strong>说明：</strong></p><ul><li>匿名函数自执行调用，数据是私有的，只能通过暴露出去的方法操作</li><li>依赖的其它模块通过参数注入</li></ul><p><strong>代码实现:</strong></p><div class="language-js"><pre><code><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">window<span class="token punctuation">,</span> $</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  <span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token string">&#39;www.baidu.com&#39;</span>  <span class="token comment">//操作数据的函数  </span>\n  <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//用于暴露有函数    </span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">foo() </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>data<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>   \n    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">&#39;body&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">&#39;background&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;red&#39;</span><span class="token punctuation">)</span>   \n  <span class="token punctuation">}</span>\n  <span class="token comment">//暴露方法   </span>\n  window<span class="token punctuation">.</span>myModule <span class="token operator">=</span> <span class="token punctuation">{</span> foo <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> jQuery<span class="token punctuation">)</span>\n</code></pre></div><h2 id="二、commonjs-规范"><a class="header-anchor" href="#二、commonjs-规范" aria-hidden="true">#</a> 二、CommonJS 规范</h2><p><strong>说明:</strong></p><p>1、每个文件都是一个模块，存在模块作用域，文件内部定义的变量、函数都是私有的</p><p>2、模块可多次加载，但<strong>只在首次加载时会运行一次</strong>，并将<strong>执行结果</strong>进行缓存，后续再次加载直接读取缓存结果</p><p>3、模块加载的顺序，按照其在代码中出现的顺序</p><p>4、模块加载机制是<strong>值拷贝</strong>，模块一旦输出个值，后续模块内部改变都影响不了这个值</p><p><strong>语法</strong></p><ul><li>导出: <code>module.exports / exports</code></li><li>导入: <code>require</code></li></ul><p>说明:</p><p>1、每个模块内部，<code>module</code> 变量代表当前模块，其 <code>exports</code> 属性代表模块对外输出接</p><p>2、加载某个模块，就是加载该模块的 <code>module.exports</code> 属性</p><p><strong>实现</strong></p><ul><li><p>服务端实现: 借助 <code>node.js</code> 特性</p></li><li><p>浏览器端实现: 借助 <code>Browserify</code></p></li><li><p>区分:</p><p>服务端，文件都存储在硬盘中，可实时读取，动态加载模块</p><p>使用 <code>Browserify</code> 在编译阶段就会打包 <code>require</code></p></li></ul><p><strong>优缺点</strong></p><ul><li>借助 <code>node.js</code> 特性，可以实现按需加载，但无法实现 <code>tree-shaking</code></li><li><code>if (true) { require(&#39;xxx&#39;)}</code></li></ul><h2 id="三、amd-规范"><a class="header-anchor" href="#三、amd-规范" aria-hidden="true">#</a> 三、AMD 规范</h2><p><strong>说明</strong></p><p>1、<code>AMD</code> 规则支持<strong>异步加载</strong>模块，在浏览器环境，需要从服务端获取文件，所以必须支持异步，所以浏览器一般采用 <code>AMD</code> 规范</p><p><strong>语法</strong></p><ul><li>定义无依赖模块:<div class="language-js"><pre><code><span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> 模块<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div></li><li>定义依赖模块:<div class="language-js"><pre><code><span class="token function">define</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&#39;module1&#39;</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">m1<span class="token punctuation">,</span> m2</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> 模块<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div></li><li>导入模块:<div class="language-js"><pre><code><span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&#39;module1&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;module2&#39;</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">m1<span class="token punctuation">,</span> m2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    \n  <span class="token comment">// 使用 m1/m2</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div></li></ul><p><strong>实现</strong></p><ul><li><code>require.js</code> 工具库</li><li>通过 <code>define</code> 方法，将代码定义为模块</li><li>通过 <code>require</code> 方法，实现代码的模块加载</li></ul><p><strong>优点</strong></p><ul><li>可以用于浏览器环境，并且允许非同步加载模块，</li><li>也可以根据需要<strong>动态加载</strong>模块</li></ul><h2 id="四、cmd-规范"><a class="header-anchor" href="#四、cmd-规范" aria-hidden="true">#</a> 四、CMD 规范</h2><p><strong>说明</strong></p><p>CMD规范整合了CommonJS和AMD规范的特点，模块的加载是异步的，模块使用时才会加载执行</p><p><strong>语法</strong></p><ul><li>使用 <code>define</code> 定义模块</li><li>使用 <code>require</code> 同步引入, <code>require.async</code> 异步引入依赖的模块</li><li>使用 <code>module.exports</code> 或 <code>exports</code> 导出模块</li></ul><p><strong>实现</strong></p><p><strong>Sea.js</strong></p><div class="language-js"><pre><code><span class="token comment">//定义有依赖的模块</span>\n<span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">require<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> module</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   \n  <span class="token comment">//引入依赖模块(同步)     </span>\n  <span class="token keyword">var</span> module2 <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;./module2&#39;</span><span class="token punctuation">)</span>  \n\n  <span class="token comment">//引入依赖模块(异步)</span>\n  require<span class="token punctuation">.</span><span class="token function">async</span><span class="token punctuation">(</span><span class="token string">&#39;./module3&#39;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">m3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n  <span class="token comment">//暴露模块  </span>\n  exports<span class="token punctuation">.</span>xxx <span class="token operator">=</span> value\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><h2 id="五、umd-规范"><a class="header-anchor" href="#五、umd-规范" aria-hidden="true">#</a> 五、UMD 规范</h2><p><strong>说明</strong></p><p>提供一个前后端跨平台的解决方案(支持<code>AMD</code>与<code>CommonJS</code>模块方式)</p><p><strong>语法</strong></p><p>1、先判断是否支持<code>Node.js</code>模块格式（<code>exports</code>是否存在），存在则使用<code>Node.js</code>模块格式</p><p>2、再判断是否支持<code>AMD</code>（<code>define</code>是否存在），存在则使用<code>AMD</code>方式加载模块</p><p>3、前两个都不存在，则将模块公开到全局（<code>window</code>或<code>global</code>）</p><h2 id="六、es-模块化规范"><a class="header-anchor" href="#六、es-模块化规范" aria-hidden="true">#</a> 六、ES 模块化规范</h2><p><strong>说明</strong></p><p>1、<code>ES</code> 模块化的设计思想在于<strong>静态化</strong>，在编译时就能确定模块的依赖关系，以及输入和输出的变量</p><p>2、利用静态化的思想，有利于做 <code>tree-shaking</code> 优化，减少代码打包体检</p><p>3、<code>ES6</code> 模块输出的是值的引用，并不会缓存值</p><p><strong>语法</strong></p><ul><li>使用 <code>export / export default</code> 导出模块</li><li>使用 <code>import</code> 导入</li></ul><p><strong>其它</strong></p><p>1、<code>export / export default</code> 的区别</p><ul><li><p><code>export</code> (推荐): 在导入时需要知道模块的导出内容，利于 <code>tree-shaking</code></p></li><li><p><code>export default</code>, 将模块作为整体进行导出，在导入时可以重命名</p></li></ul><h2 id="七、区别"><a class="header-anchor" href="#七、区别" aria-hidden="true">#</a> 七、区别</h2><blockquote><p>ES6 模块与 CommonJS 模块的差异?</p></blockquote><ul><li><p><code>CommonJS</code> 模块输出的是一个值的拷贝，<code>ES6</code> 模块输出的是值的 引用</p><div class="language-js"><pre><code><span class="token comment">// lib.js</span>\n<span class="token keyword">export</span> <span class="token keyword">let</span> counter <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>\n<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">incCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  counter<span class="token operator">++</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// main.js</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> counter<span class="token punctuation">,</span> incCounter <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./lib&#39;</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>\n<span class="token function">incCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 4</span>\n</code></pre></div><p>ES6 模块是 <strong>动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块</strong>。</p></li><li><p><code>CommonJS</code> 模块是运行时加载，<code>ES6</code> 模块是编译时输出接口</p><p><code>CommonJS</code> 加载的是一个对象（即<code>module.exports</code>属性），该对象只有在脚本运行完才会生成。而 <code>ES6</code> 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成</p></li></ul>',71);p.render=function(a,o,p,e,c,l){return n(),s("div",null,[t])};export default p;export{o as __pageData};
