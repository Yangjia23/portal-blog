import{o as e,c,d as o}from"./app.f4d85410.js";const d='{"title":"一、基本构建流程","description":"","frontmatter":{},"headers":[{"level":2,"title":"一、基本构建流程","slug":"一、基本构建流程"},{"level":3,"title":"1.1、初始化参数","slug":"_1-1、初始化参数"},{"level":3,"title":"1.2、开始编译","slug":"_1-2、开始编译"},{"level":3,"title":"1.3、编译模块","slug":"_1-3、编译模块"},{"level":3,"title":"1.4、完成编译模块","slug":"_1-4、完成编译模块"},{"level":3,"title":"1.5、输出完成","slug":"_1-5、输出完成"},{"level":2,"title":"二、核心概念","slug":"二、核心概念"},{"level":3,"title":"2.1、compiler","slug":"_2-1、compiler"},{"level":3,"title":"2.2、compilation","slug":"_2-2、compilation"}],"relativePath":"frontend-graph/工程化/2、webpack 工作流程.md","lastUpdated":1625673383099}',a={},l=o('<h2 id="一、基本构建流程"><a class="header-anchor" href="#一、基本构建流程" aria-hidden="true">#</a> 一、基本构建流程</h2><h3 id="_1-1、初始化参数"><a class="header-anchor" href="#_1-1、初始化参数" aria-hidden="true">#</a> 1.1、初始化参数</h3><p>从配置文件和 <code>Shell</code> 命令中读取和合并参数，得多最终的配置 <code>config</code></p><h3 id="_1-2、开始编译"><a class="header-anchor" href="#_1-2、开始编译" aria-hidden="true">#</a> 1.2、开始编译</h3><p>调用 <code>webpack</code> 函数接受 <code>config</code> 配置信息，并初始化 <code>complier</code> 对象, 加载配置的所有 <code>plugin</code>, 执行<code>complier.run</code> 方法进入模版编译阶段, 根据配置项 <code>entry</code> 确定入口文件</p><h3 id="_1-3、编译模块"><a class="header-anchor" href="#_1-3、编译模块" aria-hidden="true">#</a> 1.3、编译模块</h3><p>每一次新的编译都会实例化一个 <code>compilation</code> 对象，记录本次编译的基本信息。编译从入口文件出发：</p><ul><li><p>调用合适的 <code>loader</code> 对模块进行处理，转换成标准的<code>js</code>模块</p></li><li><p>调用第三方插件<code>acorn</code>对标准<code>js</code>模块进行分析，收集模块依赖项，同时会递归每个依赖项，收集依赖项的依赖信息，如此往复，最终会得到一个依赖树</p></li></ul><h3 id="_1-4、完成编译模块"><a class="header-anchor" href="#_1-4、完成编译模块" aria-hidden="true">#</a> 1.4、完成编译模块</h3><p>根据入口和模块的依赖关系，将多个模块组装成一个个 <code>chunk</code>, 再将每个 <code>chunk</code> 转化成一个单独的文件加入到<strong>输出列表</strong>（ ps: <em>这步是修改输出文件内容的最后机会</em> ）</p><h3 id="_1-5、输出完成"><a class="header-anchor" href="#_1-5、输出完成" aria-hidden="true">#</a> 1.5、输出完成</h3><p>确定好输出内容后，按照配置确定输出的文件名和路径，把文件内容写入到文件系统中</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>在上述整个过程中，<code>webpack</code> 会在特定的时间<strong>广播</strong>特定的事件( <code>hook</code>钩子函数 )，插件在监听到感兴趣的事件后会执行回调函数，利用 <code>webpack</code> 提供的 <code>api</code> 修改最后的输出结果</p></div><h2 id="二、核心概念"><a class="header-anchor" href="#二、核心概念" aria-hidden="true">#</a> 二、核心概念</h2><h3 id="_2-1、compiler"><a class="header-anchor" href="#_2-1、compiler" aria-hidden="true">#</a> 2.1、compiler</h3><p>编译器对象，其实例包含了完整的 <code>webpack</code> 配置，且全局只有一个 <code>compiler</code> 实例，相当于 <code>webpack</code> 的骨架或神经中枢，通过该对象可访问 <code>webpack</code> 内部环境</p><h3 id="_2-2、compilation"><a class="header-anchor" href="#_2-2、compilation" aria-hidden="true">#</a> 2.2、compilation</h3><p><code>compilation</code> 对象代表了一次资源版本构建。当运行 <code>webpack</code> 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 <code>compilation</code>，从而生成一组新的编译资源</p>',18);a.render=function(o,d,a,i,r,t){return e(),c("div",null,[l])};export default a;export{d as __pageData};
