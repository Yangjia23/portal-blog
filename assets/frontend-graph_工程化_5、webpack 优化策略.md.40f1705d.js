import{o as n,c as s,d as a}from"./app.e54d5190.js";const e='{"title":"构建生产版本 {#building-for-production}","description":"","frontmatter":{},"headers":[{"level":2,"title":"一、构建过程提速","slug":"一、构建过程提速"},{"level":3,"title":"1.1、耗时分析","slug":"_1-1、耗时分析"},{"level":3,"title":"1.2、缩小范围","slug":"_1-2、缩小范围"},{"level":3,"title":"1.3、利用缓存","slug":"_1-3、利用缓存"},{"level":3,"title":"1.4、多进程处理","slug":"_1-4、多进程处理"},{"level":2,"title":"二、压缩打包体积","slug":"二、压缩打包体积"},{"level":3,"title":"2.1、体积分析","slug":"_2-1、体积分析"},{"level":3,"title":"2.2、代码压缩","slug":"_2-2、代码压缩"},{"level":3,"title":"2.3、删除无用代码","slug":"_2-3、删除无用代码"},{"level":3,"title":"2.4、代码分割","slug":"_2-4、代码分割"},{"level":3,"title":"2.5、设置CDN","slug":"_2-5、设置cdn"}],"relativePath":"frontend-graph/工程化/5、webpack 优化策略.md","lastUpdated":1625503850308}',o={},p=a('<h1 id="构建生产版本-building-for-production"><a class="header-anchor" href="#构建生产版本-building-for-production" aria-hidden="true">#</a> 构建生产版本 {#building-for-production}</h1><p>当项目越来越大，<code>webpack</code> 的瓶颈就体现在两个方面，分别是：</p><ul><li>构建过程时间太长</li><li>打包的结果体积太大</li></ul><p>所以，webpack 的性能优化需要从这两个痛点下手</p><h2 id="一、构建过程提速"><a class="header-anchor" href="#一、构建过程提速" aria-hidden="true">#</a> 一、构建过程提速</h2><h3 id="_1-1、耗时分析"><a class="header-anchor" href="#_1-1、耗时分析" aria-hidden="true">#</a> 1.1、耗时分析</h3><p>使用<code>SpeedMeasureWebpackPlugin</code> 插件可统计打包构建过程中每个 <code>loader</code>、<code>plugin</code> 所消耗的时间</p><div class="language-js"><pre><code><span class="token keyword">const</span> SpeedMeasureWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;speed-measure-webpack-plugin&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> smw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SpeedMeasureWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span>smw<span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token comment">// config 配置</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre></div><h3 id="_1-2、缩小范围"><a class="header-anchor" href="#_1-2、缩小范围" aria-hidden="true">#</a> 1.2、缩小范围</h3><ul><li><p><strong>extensions</strong>: 指定 <code>extensions</code> 后导入文件不需要添加文件扩展名，<code>webpack</code> 会依次尝试添加扩展名进行尝试</p></li><li><p><strong>alias</strong>: 配置别名，可加快 <code>webpack</code> 查找模块速度</p></li><li><p><strong>exclude / include</strong>: 确保转译尽可能少的文件, <code>exclude</code>指定要排除的文件，<code>include</code> 指定要包含的文件，<code>exclude</code> 的优先级高于 <code>include</code></p></li><li><p><strong>external</strong>: 当引入一个库，但又不想让 <code>webpack</code> 打包，并且不影响正常导入使用，可在 <code>external</code> 中进行配置</p></li><li><p><strong>noParse</strong>: <code>module.noParse </code> 字段用于配置哪些模块文件的内容不需要进行解析，过滤的文件中不能使用 <code>import</code>, <code>require</code> 等语法</p></li></ul><h3 id="_1-3、利用缓存"><a class="header-anchor" href="#_1-3、利用缓存" aria-hidden="true">#</a> 1.3、利用缓存</h3><p>利用缓存可以提升重复构建的速度</p><ul><li><p><strong>babel-loader</strong>: <code>Babel</code> 在转译JS文件时性能消耗高，可将 <code>babel-loader</code> 执行的结果进行缓存，当重新打包时会尝试读取缓存。</p><p>默认存放位置是 <code>node_modules/.cache/babel-loader</code></p><div class="language-js"><pre><code><span class="token punctuation">{</span>\n  loader<span class="token operator">:</span> <span class="token string">&#39;babel-loader&#39;</span><span class="token punctuation">,</span>\n  options<span class="token operator">:</span> <span class="token punctuation">{</span>\n    cacheDirectory<span class="token operator">:</span> <span class="token boolean">true</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div></li><li><p><strong>cache-loader</strong>: 在一些性能开销大的 <code>loader</code> 之前添加 <code>cache-loader</code> ，可以将<code>loader</code>处理结果缓存到磁盘中</p><p>默认保存在 <code>node_modules/.cache/cache-loader</code> 目录下</p><div class="language-js"><pre><code><span class="token punctuation">{</span>\n  test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\\.css$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>\n  use<span class="token operator">:</span> <span class="token punctuation">[</span>\n    <span class="token string">&#39;cache-loader&#39;</span><span class="token punctuation">,</span>\n    <span class="token string">&#39;logger-loader&#39;</span><span class="token punctuation">,</span>\n    <span class="token string">&#39;style-loader&#39;</span><span class="token punctuation">,</span>\n    <span class="token string">&#39;css-loader&#39;</span>\n  <span class="token punctuation">]</span>\n<span class="token punctuation">}</span>\n</code></pre></div></li><li><p><strong>hard-source-webpack-plugin</strong> : 为模块提供中间缓存，节约第二次构建时间。（ <code>webpack5</code>中内置 ）</p></li></ul><h3 id="_1-4、多进程处理"><a class="header-anchor" href="#_1-4、多进程处理" aria-hidden="true">#</a> 1.4、多进程处理</h3><ul><li><strong><code>thread-loader</code></strong>: 放在其它 <code>loader</code> 之前，后置的 <code>loader</code> 就会在一个单独的 <code>worker</code> 池中运行</li></ul><h2 id="二、压缩打包体积"><a class="header-anchor" href="#二、压缩打包体积" aria-hidden="true">#</a> 二、压缩打包体积</h2><h3 id="_2-1、体积分析"><a class="header-anchor" href="#_2-1、体积分析" aria-hidden="true">#</a> 2.1、体积分析</h3><p>使用<code>webpack-bundle-analyzer</code> 插件可以可视化展示打包出的文件包含哪些，大小占比如何，模块包含关系，依赖项等等，有利于我们进行优化。</p><div class="language-js"><pre><code><span class="token keyword">const</span> BundleAnalyzerPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;webpack-bundle-analyzer&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>BundleAnalyzerPlugin<span class="token punctuation">;</span>\n\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>\n  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>\n    <span class="token keyword">new</span> <span class="token class-name">BundleAnalyzerPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">]</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="_2-2、代码压缩"><a class="header-anchor" href="#_2-2、代码压缩" aria-hidden="true">#</a> 2.2、代码压缩</h3><ul><li>JS 文件：<code>TenserWebpackPlugin</code> 插件</li><li>CSS 文件：<code>OptimizeCssAssetsWebpackPlugin</code></li><li>Images：<code>image-webpack-loader</code> 对图片进行压缩和优化</li></ul><h3 id="_2-3、删除无用代码"><a class="header-anchor" href="#_2-3、删除无用代码" aria-hidden="true">#</a> 2.3、删除无用代码</h3><ul><li>JS: <code>TreeShaking</code>, 没有使用到方法不会打进 <code>bundle</code> 里面，利用<code>es6</code> 模块的特点</li><li>CSS: <code>PurgecssWebpackPlugin</code></li></ul><h3 id="_2-4、代码分割"><a class="header-anchor" href="#_2-4、代码分割" aria-hidden="true">#</a> 2.4、代码分割</h3><h4 id="_2-4-1、入口点分割：entry-point"><a class="header-anchor" href="#_2-4-1、入口点分割：entry-point" aria-hidden="true">#</a> 2.4.1、入口点分割：<code>Entry Point</code></h4><div class="language-js"><pre><code>entry<span class="token operator">:</span> <span class="token punctuation">{</span>\n  index<span class="token operator">:</span> <span class="token string">&quot;./src/index.js&quot;</span><span class="token punctuation">,</span>\n  login<span class="token operator">:</span> <span class="token string">&quot;./src/login.js&quot;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p><strong>缺点</strong>：</p><ul><li>若两个入口 <code>chunk</code> 都引用了重复模块(<code>lodash</code>),那么重复模块会被引入到每个 <code>bundle</code> 中</li><li>不够灵活，不能对核心代码做进一步拆分</li></ul><h4 id="_2-4-2、动态导入和懒加载"><a class="header-anchor" href="#_2-4-2、动态导入和懒加载" aria-hidden="true">#</a> 2.4.2、动态导入和懒加载</h4><p><strong>按需加载</strong>：根据用户当前需要用什么功能就只加载该功能对应的代码</p><p><strong>拆分原则</strong>:</p><ul><li>按照网站功能(或路由)拆分，一类功能对应一个 <code>chunk</code></li><li>首页需要的功能模块直接加载，展示给用户</li><li>被分割出去的代码需要一个按需加载的时机</li></ul><p>都是使用 <code>import()</code> 关键字来实现的</p><h4 id="_2-4-3、提取公共代码"><a class="header-anchor" href="#_2-4-3、提取公共代码" aria-hidden="true">#</a> 2.4.3、提取公共代码</h4><p><strong>拆分准则</strong>:</p><ul><li>各种类库，适合长期存储</li><li>页面之间的公共代码</li><li>每个页面单独生成的文件</li></ul><p><strong>splitChunks</strong></p><div class="language-js"><pre><code>splitChunks<span class="token operator">:</span> <span class="token punctuation">{</span>\n  chunks<span class="token operator">:</span> <span class="token string">&quot;all&quot;</span><span class="token punctuation">,</span> <span class="token comment">//默认作用于异步chunk，值为 all/initial/async</span>\n  minSize<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment">//默认值是30kb,代码块的最小尺寸</span>\n  minChunks<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">//被多少模块共享, 在分割之前模块的被引用次数</span>\n  maxAsyncRequests<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token comment">//限制异步模块内部的并行最大请求数的，可以理解为是每个import()它里面的最大并行请求数量</span>\n  maxInitialRequests<span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token comment">//限制入口的拆分数量</span>\n  name<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">//打包后的名称，默认是chunk的名字通过分隔符（默认是～）分隔开，如vendor~</span>\n  automaticNameDelimiter<span class="token operator">:</span> <span class="token string">&quot;~&quot;</span><span class="token punctuation">,</span> <span class="token comment">//默认webpack将会使用入口名和代码块的名称生成命名,比如 &#39;vendors~main.js&#39;</span>\n  cacheGroups<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token comment">//设置缓存组用来抽取满足不同规则的chunk,下面以生成common为例</span>\n    vendors<span class="token operator">:</span> <span class="token punctuation">{</span>\n      chunks<span class="token operator">:</span> <span class="token string">&quot;all&quot;</span><span class="token punctuation">,</span>\n      test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">node_modules</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span> <span class="token comment">//条件</span>\n      priority<span class="token operator">:</span> <span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token comment">///优先级，一个chunk很可能满足多个缓存组，会被抽取到优先级高的缓存组中,为了能够让自定义缓存组有更高的优先级(默认0),默认缓存组的priority属性为负值.</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    commons<span class="token operator">:</span> <span class="token punctuation">{</span>\n      chunks<span class="token operator">:</span> <span class="token string">&quot;all&quot;</span><span class="token punctuation">,</span>\n      minSize<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment">//最小提取字节数</span>\n      minChunks<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token comment">//最少被几个chunk引用</span>\n      priority<span class="token operator">:</span> <span class="token operator">-</span><span class="token number">20</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="_2-5、设置cdn"><a class="header-anchor" href="#_2-5、设置cdn" aria-hidden="true">#</a> 2.5、设置CDN</h3><p><code>CDN</code> 又叫内容分发网络，通过将资源部署到全球各地，用户在访问时按照就近原则从最近的服务器上下载资源，从而加速获取资源的速度</p><p><strong>缓存设置</strong>：</p><ul><li><code>HTML</code> 文件不设置缓存，放到自己服务器上</li><li>静态 <code>JS</code>、<code>CSS</code> 文件开启 <code>CDN</code> 和缓存，并且文件名带上 <code>hash</code> 值</li><li>为了并行不加塞，把不同资源的文件部署到不同的<code>CDN</code>服务器上</li></ul>',42);o.render=function(a,e,o,t,c,l){return n(),s("div",null,[p])};export default o;export{e as __pageData};
